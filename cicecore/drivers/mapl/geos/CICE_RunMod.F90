!=======================================================================
!
!  Main driver for time stepping of CICE.
!
!  authors Elizabeth C. Hunke, LANL
!          Philip W. Jones, LANL
!          William H. Lipscomb, LANL
!
! 2006 ECH: moved exit timeLoop to prevent execution of unnecessary timestep
! 2006 ECH: Streamlined for efficiency
! 2006 ECH: Converted to free source form (F90)
! 2007 BPB: Modified Delta-Eddington shortwave interface
! 2008 ECH: moved ESMF code to its own driver

      module CICE_RunMod

      use ice_kinds_mod
      use ice_fileunits, only: nu_diag
      use ice_arrays_column, only: oceanmixed_ice
      use ice_domain_size, only: max_blocks, ncat, max_nstrm, nilyr
      use ice_constants, only: c0, c1, c5, c10, c20, c180
      use ice_constants, only: field_loc_center, field_type_scalar
      use ice_exit, only: abort_ice
      use icepack_intfc, only: icepack_warnings_flush, icepack_warnings_aborted
      use icepack_intfc, only: icepack_max_iso, icepack_max_aero
      use icepack_intfc, only: icepack_query_parameters
      use icepack_intfc, only: icepack_query_tracer_flags, icepack_query_tracer_sizes

      implicit none
      private
      public :: CICE_Run, ice_step, ice_fast_physics, ice_radiation

!=======================================================================

      contains

!=======================================================================
!
!  This is the main driver routine for advancing CICE forward in time.
!
!  author Elizabeth C. Hunke, LANL
!         Philip W. Jones, LANL
!         William H. Lipscomb, LANL

      subroutine CICE_Run

      use ice_calendar, only: istep, istep1, dt, calendar, advance_timestep
      use ice_forcing, only: get_forcing_atmo, get_forcing_ocn, &
          get_wave_spec
      use ice_forcing_bgc, only: get_forcing_bgc, get_atm_bgc, &
          fiso_default, faero_default
      use ice_flux, only: init_flux_atm, init_flux_ocn
      use ice_timers, only: ice_timer_start, ice_timer_stop, &
          timer_couple, timer_step
      logical (kind=log_kind) :: &
          tr_iso, tr_aero, tr_zaero, skl_bgc, z_tracers, wave_spec, tr_fsd
      character(len=*), parameter :: subname = '(CICE_Run)'

      !--------------------------------------------------------------------
      !  initialize error code and step timer
      !--------------------------------------------------------------------

      call ice_timer_start(timer_step)   ! start timing entire run

      call icepack_query_parameters(skl_bgc_out=skl_bgc, &
                                    z_tracers_out=z_tracers, &
                                    wave_spec_out=wave_spec)
      call icepack_query_tracer_flags(tr_iso_out=tr_iso, &
                                      tr_aero_out=tr_aero, &
                                      tr_zaero_out=tr_zaero, &
                                      tr_fsd_out=tr_fsd)
      call icepack_warnings_flush(nu_diag)
      if (icepack_warnings_aborted()) call abort_ice(error_message=subname, &
         file=__FILE__, line=__LINE__)

      !--------------------------------------------------------------------
      ! timestep loop
      !--------------------------------------------------------------------

      !call ice_timer_start(timer_couple)  ! atm/ocn coupling

      call advance_timestep()  ! advance timestep and update calendar data

      !if (z_tracers) call get_atm_bgc                   ! biogeochemistry

      !call init_flux_atm  ! Initialize atmosphere fluxes sent to coupler
      !call init_flux_ocn  ! initialize ocean fluxes sent to coupler

      !call ice_timer_stop(timer_couple)    ! atm/ocn coupling

      call ice_step

      !--------------------------------------------------------------------
      ! end of timestep loop
      !--------------------------------------------------------------------

      call ice_timer_stop(timer_step)   ! end timestepping loop timer

      end subroutine CICE_Run

!=======================================================================
!
!  Calls drivers for physics components, some initialization, and output
!
!  author Elizabeth C. Hunke, LANL
!         William H. Lipscomb, LANL

      subroutine ice_step

      use ice_boundary, only: ice_HaloUpdate
      use ice_calendar, only: dt, dt_dyn, ndtd, diagfreq, write_restart, istep
      use ice_calendar, only: idate, msec
      use ice_diagnostics, only: init_mass_diags, runtime_diags, debug_model, debug_ice
      use ice_diagnostics_bgc, only: hbrine_diags, zsal_diags, bgc_diags
      use ice_domain, only: halo_info, nblocks
      use ice_dyn_eap, only: write_restart_eap
      use ice_dyn_shared, only: kdyn, kridge
      use ice_flux, only: scale_factor, init_history_therm, &
          daidtt, daidtd, dvidtt, dvidtd, dagedtt, dagedtd
      use ice_history, only: accum_hist
      use ice_history_bgc, only: init_history_bgc
      use ice_restart, only: final_restart
      use ice_restart_column, only: write_restart_age, write_restart_FY, &
          write_restart_lvl, write_restart_pond_lvl, &
          write_restart_pond_topo, write_restart_aero, write_restart_fsd, &
          write_restart_iso, write_restart_bgc, write_restart_hbrine, &
          write_restart_snow
      use ice_restart_driver, only: dumpfile
      use ice_restoring, only: restore_ice, ice_HaloRestore
      use ice_step_mod, only: prep_radiation, step_therm1, step_therm2, &
          update_state, step_dyn_horiz, step_dyn_ridge, step_radiation, &
          biogeochemistry, step_prep, step_dyn_wave, step_snow
      use ice_timers, only: ice_timer_start, ice_timer_stop, &
          timer_diags, timer_column, timer_thermo, timer_bound, &
          timer_hist, timer_readwrite
      use ice_communicate, only: MPI_COMM_ICE
      use ice_prescribed_mod

      integer (kind=int_kind) :: &
         iblk        , & ! block index
         k           , & ! dynamics supercycling index
         ktherm          ! thermodynamics is off when ktherm = -1

      real (kind=dbl_kind) :: &
         offset          ! d(age)/dt time offset

      logical (kind=log_kind) :: &
          tr_iage, tr_FY, tr_lvl, tr_fsd, tr_snow, &
          tr_pond_lvl, tr_pond_topo, tr_brine, tr_iso, tr_aero, &
          calc_Tsfc, skl_bgc, solve_zsal, z_tracers, wave_spec

      character(len=*), parameter :: subname = '(ice_step)'

      character (len=char_len) :: plabeld

      !if (debug_model) then
      !   plabeld = 'beginning time step'
      !   do iblk = 1, nblocks
      !      call debug_ice (iblk, plabeld)
      !   enddo
      !endif

      call icepack_query_parameters(calc_Tsfc_out=calc_Tsfc, skl_bgc_out=skl_bgc, &
           solve_zsal_out=solve_zsal, z_tracers_out=z_tracers, ktherm_out=ktherm, &
           wave_spec_out=wave_spec)
      call icepack_query_tracer_flags(tr_iage_out=tr_iage, tr_FY_out=tr_FY, &
           tr_lvl_out=tr_lvl, tr_pond_lvl_out=tr_pond_lvl, &
           tr_pond_topo_out=tr_pond_topo, tr_brine_out=tr_brine, tr_aero_out=tr_aero, &
           tr_iso_out=tr_iso, tr_fsd_out=tr_fsd, tr_snow_out=tr_snow)
      call icepack_warnings_flush(nu_diag)
      if (icepack_warnings_aborted()) call abort_ice(error_message=subname, &
         file=__FILE__, line=__LINE__)


         call ice_timer_start(timer_column)  ! continue column physics
         call ice_timer_start(timer_thermo)  ! thermodynamics

         !$OMP PARALLEL DO PRIVATE(iblk)
         do iblk = 1, nblocks

            if (ktherm >= 0) then

      !-----------------------------------------------------------------
      ! thermodynamics and biogeochemistry
      !-----------------------------------------------------------------

               call biogeochemistry (dt, iblk) ! biogeochemistry
               !if (debug_model) then
               !   plabeld = 'post biogeochemistry'
               !   call debug_ice (iblk, plabeld)
               !endif

               if (.not.prescribed_ice) &
                  call step_therm2  (dt, iblk) ! ice thickness distribution thermo
                  if (debug_model) then
                     plabeld = 'post step_therm2'
                     call debug_ice (iblk, plabeld)
                  endif

            endif ! ktherm > 0

         enddo ! iblk
         !$OMP END PARALLEL DO

         ! clean up, update tendency diagnostics
         offset = dt
         call update_state (dt, daidtt, dvidtt, dagedtt, offset)

         call ice_timer_stop(timer_thermo) ! thermodynamics
         call ice_timer_stop(timer_column) ! column physics

      !-----------------------------------------------------------------
      ! dynamics, transport, ridging
      !-----------------------------------------------------------------

         if (.not.prescribed_ice) then

         ! wave fracture of the floe size distribution
         ! note this is called outside of the dynamics subcycling loop
         if (tr_fsd .and. wave_spec) call step_dyn_wave(dt)

         do k = 1, ndtd

            ! momentum, stress, transport
            call step_dyn_horiz (dt_dyn)
            !if (debug_model) then
            !   plabeld = 'post step_dyn_horiz'
            !   do iblk = 1, nblocks
            !      call debug_ice (iblk, plabeld)
            !   enddo ! iblk
            !endif

            ! ridging
            !$OMP PARALLEL DO PRIVATE(iblk)
            do iblk = 1, nblocks
               if (kridge > 0) call step_dyn_ridge (dt_dyn, ndtd, iblk)
            enddo
            !$OMP END PARALLEL DO
            !if (debug_model) then
            !   plabeld = 'post step_dyn_ridge'
            !   do iblk = 1, nblocks
            !      call debug_ice (iblk, plabeld)
            !   enddo ! iblk
            !endif

            ! clean up, update tendency diagnostics
            offset = c0
            call update_state (dt_dyn, daidtd, dvidtd, dagedtd, offset)

         enddo
         !if (debug_model) then
         !   plabeld = 'post dynamics'
         !   do iblk = 1, nblocks
         !      call debug_ice (iblk, plabeld)
         !   enddo
         !endif

         endif  ! not prescribed ice

      !-----------------------------------------------------------------
      ! albedo, shortwave radiation
      !-----------------------------------------------------------------

         call ice_timer_start(timer_column)  ! column physics
         call ice_timer_start(timer_thermo)  ! thermodynamics

      !-----------------------------------------------------------------
      ! snow redistribution and metamorphosis
      !-----------------------------------------------------------------

         if (tr_snow) then         ! advanced snow physics
            do iblk = 1, nblocks
               call step_snow (dt, iblk)
            enddo
            call update_state (dt) ! clean up
         endif

!MHRI: CHECK THIS OMP
         !$OMP PARALLEL DO PRIVATE(iblk)
         do iblk = 1, nblocks

            !if (ktherm >= 0) call step_radiation (dt, iblk)
            !if (debug_model) then
            !   plabeld = 'post step_radiation'
            !   call debug_ice (iblk, plabeld)
            !endif

      !-----------------------------------------------------------------
      ! get ready for coupling and the next time step
      !-----------------------------------------------------------------

            call coupling_ocn (iblk)
            if (debug_model) then
               plabeld = 'post coupling_ocn'
               call debug_ice (iblk, plabeld)
            endif
         enddo ! iblk
         !$OMP END PARALLEL DO

         !call ice_timer_start(timer_bound)
         !call ice_HaloUpdate (scale_factor,     halo_info, &
         !                     field_loc_center, field_type_scalar)
         !call ice_timer_stop(timer_bound)

         call ice_timer_stop(timer_thermo) ! thermodynamics
         call ice_timer_stop(timer_column) ! column physics

      !-----------------------------------------------------------------
      ! write data
      !-----------------------------------------------------------------

         call ice_timer_start(timer_diags)  ! diagnostics
         if (mod(istep,diagfreq) == 0) then
            call runtime_diags(dt)          ! log file
            if (solve_zsal) call zsal_diags
            if (skl_bgc .or. z_tracers)  call bgc_diags
            if (tr_brine) call hbrine_diags
         endif
         call ice_timer_stop(timer_diags)   ! diagnostics

         call ice_timer_start(timer_hist)   ! history
         call accum_hist (dt)               ! history file
         call ice_timer_stop(timer_hist)    ! history

         call ice_timer_start(timer_readwrite)  ! reading/writing
         if (write_restart == 1) then
            call dumpfile     ! core variables for restarting
            if (tr_iage)      call write_restart_age
            if (tr_FY)        call write_restart_FY
            if (tr_lvl)       call write_restart_lvl
            !if (tr_pond_cesm) call write_restart_pond_cesm
            if (tr_pond_lvl)  call write_restart_pond_lvl
            if (tr_pond_topo) call write_restart_pond_topo
            if (tr_snow)      call write_restart_snow
            if (tr_fsd)       call write_restart_fsd
            if (tr_iso)       call write_restart_iso
            if (tr_aero)      call write_restart_aero
            if (solve_zsal .or. skl_bgc .or. z_tracers) &
                              call write_restart_bgc
            if (tr_brine)     call write_restart_hbrine
            if (kdyn == 2)    call write_restart_eap
            call final_restart
         endif

         call ice_timer_stop(timer_readwrite)  ! reading/writing

      end subroutine ice_step
    
!=======================================================================
!
! Prepare for coupling
!
! authors: Elizabeth C. Hunke, LANL

      subroutine coupling_prep (iblk)

      use ice_arrays_column, only: alvdfn, alidfn, alvdrn, alidrn, &
          fswthrun_vdr, fswthrun_vdf, fswthrun_idr, fswthrun_idf, &
          fswthrun_uvrdr, fswthrun_uvrdf, fswthrun_pardr, fswthrun_pardf, &
          albicen, albsnon, albpndn, apeffn, fzsal_g, fzsal, snowfracn
      use ice_blocks, only: nx_block, ny_block, get_block, block
      use ice_domain, only: blocks_ice
      use ice_calendar, only: dt, nstreams
      use ice_domain_size, only: ncat
      use ice_flux, only: alvdf, alidf, alvdr, alidr, albice, albsno, &
          albpnd, albcnt, apeff_ai, fpond, fresh, l_mpond_fresh, &
          alvdf_ai, alidf_ai, alvdr_ai, alidr_ai, fhocn_ai, &
          fresh_ai, fsalt_ai, fsalt, &
          fswthru_ai, fhocn, fswthru, scale_factor, snowfrac, &
          fswthru_vdr, fswthru_vdf, fswthru_idr, fswthru_idf, &
          fswthru_uvrdr, fswthru_uvrdf, fswthru_pardr, fswthru_pardf, &
          swvdr, swidr, swvdf, swidf, Tf, Tair, Qa, strairxT, strairyT, &
          fsens, flat, fswabs, flwout, evap, Tref, Qref, &
          scale_fluxes, frzmlt_init, frzmlt, Uref, wind
      use ice_flux_bgc, only: faero_ocn, fiso_ocn, Qref_iso, fiso_evap, &
          fzsal_ai, fzsal_g_ai, flux_bio, flux_bio_ai, &
          fnit, fsil, famm, fdmsp, fdms, fhum, fdust, falgalN, &
          fdoc, fdic, fdon, ffep, ffed, bgcflux_ice_to_ocn
      use ice_grid, only: tmask
      use ice_state, only: aicen, aice
      use ice_state, only: aice_init
      use ice_flux, only: flatn_f, fsurfn_f
      use ice_step_mod, only: ocean_mixed_layer
      use ice_timers, only: timer_couple, ice_timer_start, ice_timer_stop

      integer (kind=int_kind), intent(in) :: &
         iblk            ! block index

      ! local variables

      integer (kind=int_kind) :: &
         ilo,ihi,jlo,jhi, & ! beginning and end of physical domain
         n           , & ! thickness category index
         i,j         , & ! horizontal indices
         k           , & ! tracer index
         nbtrcr          !

      type (block) :: &
         this_block         ! block information for current block

      logical (kind=log_kind) :: &
         skl_bgc     , & !
         calc_Tsfc       !

      real (kind=dbl_kind) :: &
         cszn        , & ! counter for history averaging
         puny        , & !
         rhofresh    , & !
         netsw           ! flag for shortwave radiation presence

      character(len=*), parameter :: subname = '(coupling_prep)'

      !-----------------------------------------------------------------

         call icepack_query_parameters(puny_out=puny, rhofresh_out=rhofresh)
         call icepack_query_parameters(skl_bgc_out=skl_bgc)
         call icepack_query_tracer_sizes(nbtrcr_out=nbtrcr)
         call icepack_query_parameters(calc_Tsfc_out=calc_Tsfc)
         call icepack_warnings_flush(nu_diag)
         if (icepack_warnings_aborted()) call abort_ice(error_message=subname, &
            file=__FILE__, line=__LINE__)

      !-----------------------------------------------------------------
      ! Save current value of frzmlt for diagnostics.
      ! Update mixed layer with heat and radiation from ice.
      !-----------------------------------------------------------------

         do j = 1, ny_block
         do i = 1, nx_block
            frzmlt_init  (i,j,iblk) = frzmlt(i,j,iblk)
         enddo
         enddo

         call ice_timer_start(timer_couple,iblk)   ! atm/ocn coupling

         if (oceanmixed_ice) &
         call ocean_mixed_layer (dt,iblk) ! ocean surface fluxes and sst

      !-----------------------------------------------------------------
      ! Aggregate albedos
      !-----------------------------------------------------------------

         do j = 1, ny_block
         do i = 1, nx_block
            alvdf(i,j,iblk) = c0
            alidf(i,j,iblk) = c0
            alvdr(i,j,iblk) = c0
            alidr(i,j,iblk) = c0
            
            fswthru_vdr(i,j,iblk) = c0
            fswthru_vdf(i,j,iblk) = c0
            fswthru_idr(i,j,iblk) = c0
            fswthru_idf(i,j,iblk) = c0

            fswthru_uvrdr(i,j,iblk) = c0
            fswthru_uvrdf(i,j,iblk) = c0
            fswthru_pardr(i,j,iblk) = c0
            fswthru_pardf(i,j,iblk) = c0

            albice(i,j,iblk) = c0
            albsno(i,j,iblk) = c0
            albpnd(i,j,iblk) = c0
            apeff_ai(i,j,iblk) = c0
            snowfrac(i,j,iblk) = c0

            ! for history averaging
            cszn = c0
            netsw = swvdr(i,j,iblk)+swidr(i,j,iblk)+swvdf(i,j,iblk)+swidf(i,j,iblk)
            if (netsw > puny) cszn = c1
            do n = 1, nstreams
               albcnt(i,j,iblk,n) = albcnt(i,j,iblk,n) + cszn
            enddo
         enddo
         enddo

         this_block = get_block(blocks_ice(iblk),iblk)
         ilo = this_block%ilo
         ihi = this_block%ihi
         jlo = this_block%jlo
         jhi = this_block%jhi

         do n = 1, ncat
         do j = jlo, jhi
         do i = ilo, ihi
            if (aicen(i,j,n,iblk) > puny) then

            alvdf(i,j,iblk) = alvdf(i,j,iblk) &
               + alvdfn(i,j,n,iblk)*aicen(i,j,n,iblk)
            alidf(i,j,iblk) = alidf(i,j,iblk) &
               + alidfn(i,j,n,iblk)*aicen(i,j,n,iblk)
            alvdr(i,j,iblk) = alvdr(i,j,iblk) &
               + alvdrn(i,j,n,iblk)*aicen(i,j,n,iblk)
            alidr(i,j,iblk) = alidr(i,j,iblk) &
               + alidrn(i,j,n,iblk)*aicen(i,j,n,iblk)
  
            fswthru_vdr(i,j,iblk) = fswthru_vdr(i,j,iblk) &
               + fswthrun_vdr(i,j,n,iblk)*aicen(i,j,n,iblk)
            fswthru_vdf(i,j,iblk) = fswthru_vdf(i,j,iblk) &
               + fswthrun_vdf(i,j,n,iblk)*aicen(i,j,n,iblk)
            fswthru_idr(i,j,iblk) = fswthru_idr(i,j,iblk) &
               + fswthrun_idr(i,j,n,iblk)*aicen(i,j,n,iblk)
            fswthru_idf(i,j,iblk) = fswthru_idf(i,j,iblk) &
               + fswthrun_idf(i,j,n,iblk)*aicen(i,j,n,iblk)

            fswthru_uvrdr(i,j,iblk) = fswthru_uvrdr(i,j,iblk) &
               + fswthrun_uvrdr(i,j,n,iblk)*aicen(i,j,n,iblk)
            fswthru_uvrdf(i,j,iblk) = fswthru_uvrdf(i,j,iblk) &
               + fswthrun_uvrdf(i,j,n,iblk)*aicen(i,j,n,iblk)
            fswthru_pardr(i,j,iblk) = fswthru_pardr(i,j,iblk) &
               + fswthrun_pardr(i,j,n,iblk)*aicen(i,j,n,iblk)
            fswthru_pardf(i,j,iblk) = fswthru_pardf(i,j,iblk) &
               + fswthrun_pardf(i,j,n,iblk)*aicen(i,j,n,iblk)

            netsw = swvdr(i,j,iblk) + swidr(i,j,iblk) &
                  + swvdf(i,j,iblk) + swidf(i,j,iblk)
            if (netsw > puny) then ! sun above horizon
            albice(i,j,iblk) = albice(i,j,iblk) &
               + albicen(i,j,n,iblk)*aicen(i,j,n,iblk)
            albsno(i,j,iblk) = albsno(i,j,iblk) &
               + albsnon(i,j,n,iblk)*aicen(i,j,n,iblk)
            albpnd(i,j,iblk) = albpnd(i,j,iblk) &
               + albpndn(i,j,n,iblk)*aicen(i,j,n,iblk)
            endif

            apeff_ai(i,j,iblk) = apeff_ai(i,j,iblk) &       ! for history
               + apeffn(i,j,n,iblk)*aicen(i,j,n,iblk)
            snowfrac(i,j,iblk) = snowfrac(i,j,iblk) &       ! for history
               + snowfracn(i,j,n,iblk)*aicen(i,j,n,iblk)

            endif ! aicen > puny
         enddo
         enddo
         enddo

         do j = 1, ny_block
         do i = 1, nx_block

      !-----------------------------------------------------------------
      ! reduce fresh by fpond for coupling
      !-----------------------------------------------------------------

            if (l_mpond_fresh) then
               fpond(i,j,iblk) = fpond(i,j,iblk) * rhofresh/dt
               fresh(i,j,iblk) = fresh(i,j,iblk) - fpond(i,j,iblk)
            endif

      !----------------------------------------------------------------
      ! Store grid box mean albedos and fluxes before scaling by aice
      !----------------------------------------------------------------

            alvdf_ai  (i,j,iblk) = alvdf  (i,j,iblk)
            alidf_ai  (i,j,iblk) = alidf  (i,j,iblk)
            alvdr_ai  (i,j,iblk) = alvdr  (i,j,iblk)
            alidr_ai  (i,j,iblk) = alidr  (i,j,iblk)
            fresh_ai  (i,j,iblk) = fresh  (i,j,iblk)
            fsalt_ai  (i,j,iblk) = fsalt  (i,j,iblk)
            fhocn_ai  (i,j,iblk) = fhocn  (i,j,iblk)
            fswthru_ai(i,j,iblk) = fswthru(i,j,iblk)
            fzsal_ai  (i,j,iblk) = fzsal  (i,j,iblk)
            fzsal_g_ai(i,j,iblk) = fzsal_g(i,j,iblk)

            if (nbtrcr > 0) then
            do k = 1, nbtrcr
              flux_bio_ai  (i,j,k,iblk) = flux_bio  (i,j,k,iblk)
            enddo
            endif

      !-----------------------------------------------------------------
      ! Save net shortwave for scaling factor in scale_factor
      !-----------------------------------------------------------------
            scale_factor(i,j,iblk) = &
                       swvdr(i,j,iblk)*(c1 - alvdr_ai(i,j,iblk)) &
                     + swvdf(i,j,iblk)*(c1 - alvdf_ai(i,j,iblk)) &
                     + swidr(i,j,iblk)*(c1 - alidr_ai(i,j,iblk)) &
                     + swidf(i,j,iblk)*(c1 - alidf_ai(i,j,iblk))

         enddo
         enddo

      !-----------------------------------------------------------------
      ! Divide fluxes by ice area
      !  - the CESM coupler assumes fluxes are per unit ice area
      !  - also needed for global budget in diagnostics
      !-----------------------------------------------------------------

         call scale_fluxes (nx_block,            ny_block,           &
                            tmask    (:,:,iblk), nbtrcr,             &
                            icepack_max_aero,                        &
                            aice     (:,:,iblk), Tf      (:,:,iblk), &
                            Tair     (:,:,iblk), Qa      (:,:,iblk), &
                            strairxT (:,:,iblk), strairyT(:,:,iblk), &
                            fsens    (:,:,iblk), flat    (:,:,iblk), &
                            fswabs   (:,:,iblk), flwout  (:,:,iblk), &
                            evap     (:,:,iblk),                     &
                            Tref     (:,:,iblk), Qref    (:,:,iblk), &
                            fresh    (:,:,iblk), fsalt   (:,:,iblk), &
                            fhocn    (:,:,iblk),                     &
                            fswthru  (:,:,iblk),                     &
                            fswthru_vdr(:,:,iblk),                   &
                            fswthru_vdf(:,:,iblk),                   &
                            fswthru_idr(:,:,iblk),                   &
                            fswthru_idf(:,:,iblk),                   &
                            faero_ocn(:,:,:,iblk),                   &
                            alvdr    (:,:,iblk), alidr   (:,:,iblk), &
                            alvdf    (:,:,iblk), alidf   (:,:,iblk), &
                            fzsal    (:,:,iblk), fzsal_g (:,:,iblk), &
                            flux_bio (:,:,1:nbtrcr,iblk),            &
                            Qref_iso =Qref_iso (:,:,:,iblk),         &
                            fiso_evap=fiso_evap(:,:,:,iblk),         &
                            fiso_ocn =fiso_ocn (:,:,:,iblk),         &
                            Uref=Uref(:,:,iblk), wind=wind(:,:,iblk) )
 
      !-----------------------------------------------------------------
      ! Define ice-ocean bgc fluxes
      !-----------------------------------------------------------------

         if (nbtrcr > 0 .or. skl_bgc) then
            call bgcflux_ice_to_ocn (nx_block,       ny_block,           &
                                  flux_bio(:,:,1:nbtrcr,iblk),            &
                                  fnit(:,:,iblk),    fsil(:,:,iblk),      &
                                  famm(:,:,iblk),    fdmsp(:,:,iblk),     &
                                  fdms(:,:,iblk),    fhum(:,:,iblk),      &
                                  fdust(:,:,iblk),   falgalN(:,:,:,iblk), &
                                  fdoc(:,:,:,iblk),  fdic(:,:,:,iblk),    &
                                  fdon(:,:,:,iblk),  ffep(:,:,:,iblk),    &
                                  ffed(:,:,:,iblk))
         endif

         call ice_timer_stop(timer_couple,iblk)   ! atm/ocn coupling

      end subroutine coupling_prep

      subroutine coupling_atm (iblk)

      use ice_arrays_column, only: alvdfn, alidfn, alvdrn, alidrn, &
          fswthrun_vdr, fswthrun_vdf, fswthrun_idr, fswthrun_idf, &
          fswthrun_uvrdr, fswthrun_uvrdf, fswthrun_pardr, fswthrun_pardf, &
          albicen, albsnon, albpndn, apeffn, fzsal_g, fzsal, snowfracn
      use ice_blocks, only: nx_block, ny_block, get_block, block
      use ice_domain, only: blocks_ice
      use ice_calendar, only: dt, nstreams
      use ice_domain_size, only: ncat
      use ice_flux, only: alvdf, alidf, alvdr, alidr, albice, albsno, &
          albpnd, albcnt, apeff_ai, fpond, fresh, l_mpond_fresh, &
          alvdf_ai, alidf_ai, alvdr_ai, alidr_ai, fhocn_ai, &
          fresh_ai, fsalt_ai, fsalt, fsurf, fcondtop, &
          fswthru_ai, fhocn, fswthru, scale_factor, snowfrac, &
          fswthru_vdr, fswthru_vdf, fswthru_idr, fswthru_idf, &
          fswthru_uvrdr, fswthru_uvrdf, fswthru_pardr, fswthru_pardf, &
          swvdr, swidr, swvdf, swidf, Tf, Tair, Qa, strairxT, strairyT, &
          fsens, flat, fswabs, flwout, evap, Tref, Qref, &
          scale_fluxes, frzmlt_init, frzmlt, Uref, wind
      use ice_flux_bgc, only: faero_ocn, fiso_ocn, Qref_iso, fiso_evap, &
          fzsal_ai, fzsal_g_ai, flux_bio, flux_bio_ai, &
          fnit, fsil, famm, fdmsp, fdms, fhum, fdust, falgalN, &
          fdoc, fdic, fdon, ffep, ffed, bgcflux_ice_to_ocn
      use ice_grid, only: tmask, opmask
      use ice_state, only: aicen, aice, aicen_init, aice_init
      use ice_flux, only: flatn_f, fsurfn_f
      use ice_step_mod, only: ocean_mixed_layer
      use ice_timers, only: timer_couple, ice_timer_start, ice_timer_stop

      integer (kind=int_kind), intent(in) :: &
         iblk            ! block index

      ! local variables

      integer (kind=int_kind) :: &
         ilo,ihi,jlo,jhi, & ! beginning and end of physical domain
         n           , & ! thickness category index
         i,j         , & ! horizontal indices
         k           , & ! tracer index
         nbtrcr          !

      type (block) :: &
         this_block         ! block information for current block

      logical (kind=log_kind) :: &
         skl_bgc     , & !
         calc_Tsfc       !

      real (kind=dbl_kind) :: &
         cszn        , & ! counter for history averaging
         puny        , & !
         ar          , &          
         stefan_boltzmann, &
         Tffresh     , &
         rhofresh    , & !
         netsw           ! flag for shortwave radiation presence

      character(len=*), parameter :: subname = '(coupling_atm)'

      !-----------------------------------------------------------------

         call icepack_query_parameters(puny_out=puny, rhofresh_out=rhofresh)
         call icepack_query_parameters(skl_bgc_out=skl_bgc)
         call icepack_query_tracer_sizes(nbtrcr_out=nbtrcr)
         call icepack_query_parameters(calc_Tsfc_out=calc_Tsfc)
         call icepack_query_parameters(stefan_boltzmann_out=stefan_boltzmann, &
              Tffresh_out=Tffresh)
         call icepack_warnings_flush(nu_diag)
         if (icepack_warnings_aborted()) call abort_ice(error_message=subname, &
            file=__FILE__, line=__LINE__)

      !-----------------------------------------------------------------
      ! Save current value of frzmlt for diagnostics.
      ! Update mixed layer with heat and radiation from ice.
      !-----------------------------------------------------------------

         do j = 1, ny_block
         do i = 1, nx_block
            frzmlt_init  (i,j,iblk) = frzmlt(i,j,iblk)
         enddo
         enddo

         call ice_timer_start(timer_couple,iblk)   ! atm/ocn coupling

      !-----------------------------------------------------------------
      ! Aggregate albedos
      !-----------------------------------------------------------------

         do j = 1, ny_block
         do i = 1, nx_block
            alvdf(i,j,iblk) = c0
            alidf(i,j,iblk) = c0
            alvdr(i,j,iblk) = c0
            alidr(i,j,iblk) = c0
            
            albice(i,j,iblk) = c0
            albsno(i,j,iblk) = c0
            albpnd(i,j,iblk) = c0
            apeff_ai(i,j,iblk) = c0
            snowfrac(i,j,iblk) = c0

            ! for history averaging
            !cszn = c0
            !netsw = swvdr(i,j,iblk)+swidr(i,j,iblk)+swvdf(i,j,iblk)+swidf(i,j,iblk)
            !if (netsw > puny) cszn = c1
            cszn = c1
            do n = 1, nstreams
               albcnt(i,j,iblk,n) = albcnt(i,j,iblk,n) + cszn
            enddo
         enddo
         enddo

         this_block = get_block(blocks_ice(iblk),iblk)
         ilo = this_block%ilo
         ihi = this_block%ihi
         jlo = this_block%jlo
         jhi = this_block%jhi

         do n = 1, ncat
         do j = jlo, jhi
         do i = ilo, ihi
            if (aicen_init(i,j,n,iblk) > puny) then

            alvdf(i,j,iblk) = alvdf(i,j,iblk) &
               + alvdfn(i,j,n,iblk)*aicen_init(i,j,n,iblk)
            alidf(i,j,iblk) = alidf(i,j,iblk) &
               + alidfn(i,j,n,iblk)*aicen_init(i,j,n,iblk)
            alvdr(i,j,iblk) = alvdr(i,j,iblk) &
               + alvdrn(i,j,n,iblk)*aicen_init(i,j,n,iblk)
            alidr(i,j,iblk) = alidr(i,j,iblk) &
               + alidrn(i,j,n,iblk)*aicen_init(i,j,n,iblk)

            netsw = swvdr(i,j,iblk) + swidr(i,j,iblk) &
                  + swvdf(i,j,iblk) + swidf(i,j,iblk)
            !if (netsw > puny) then ! sun above horizon
            albice(i,j,iblk) = albice(i,j,iblk) &
               + albicen(i,j,n,iblk)*aicen_init(i,j,n,iblk)
            albsno(i,j,iblk) = albsno(i,j,iblk) &
               + albsnon(i,j,n,iblk)*aicen_init(i,j,n,iblk)
            albpnd(i,j,iblk) = albpnd(i,j,iblk) &
               + albpndn(i,j,n,iblk)*aicen_init(i,j,n,iblk)
            !endif

            apeff_ai(i,j,iblk) = apeff_ai(i,j,iblk) &       ! for history
               + apeffn(i,j,n,iblk)*aicen_init(i,j,n,iblk)
            snowfrac(i,j,iblk) = snowfrac(i,j,iblk) &       ! for history
               + snowfracn(i,j,n,iblk)*aicen_init(i,j,n,iblk)

            endif ! aicen_init > puny
         enddo
         enddo
         enddo

         do j = 1, ny_block
         do i = 1, nx_block

      !----------------------------------------------------------------
      ! Store grid box mean albedos and fluxes before scaling by aice
      !----------------------------------------------------------------

            alvdf_ai  (i,j,iblk) = alvdf  (i,j,iblk)
            alidf_ai  (i,j,iblk) = alidf  (i,j,iblk)
            alvdr_ai  (i,j,iblk) = alvdr  (i,j,iblk)
            alidr_ai  (i,j,iblk) = alidr  (i,j,iblk)
            fswthru_ai(i,j,iblk) = fswthru(i,j,iblk)
            fzsal_ai  (i,j,iblk) = fzsal  (i,j,iblk)
            fzsal_g_ai(i,j,iblk) = fzsal_g(i,j,iblk)


      !-----------------------------------------------------------------
      ! Save net shortwave for scaling factor in scale_factor
      !-----------------------------------------------------------------
            scale_factor(i,j,iblk) = &
                       swvdr(i,j,iblk)*(c1 - alvdr_ai(i,j,iblk)) &
                     + swvdf(i,j,iblk)*(c1 - alvdf_ai(i,j,iblk)) &
                     + swidr(i,j,iblk)*(c1 - alidr_ai(i,j,iblk)) &
                     + swidf(i,j,iblk)*(c1 - alidf_ai(i,j,iblk))

         enddo
         enddo

      !-----------------------------------------------------------------
      ! Divide fluxes by ice area
      !  - the CESM coupler assumes fluxes are per unit ice area
      !  - also needed for global budget in diagnostics
      !-----------------------------------------------------------------

         do j = 1, ny_block
         do i = 1, nx_block
             if ((tmask(i,j,iblk) .or. opmask(i,j,iblk)) .and. aice_init(i,j,iblk) > c0) then
               ar                 = c1 / aice_init(i,j,iblk)
               fsens   (i,j,iblk) = fsens   (i,j,iblk) * ar
               flat    (i,j,iblk) = flat    (i,j,iblk) * ar
               fswabs  (i,j,iblk) = fswabs  (i,j,iblk) * ar
               flwout  (i,j,iblk) = flwout  (i,j,iblk) * ar
               fsurf   (i,j,iblk) = fsurf   (i,j,iblk) * ar
               fcondtop(i,j,iblk) = fcondtop(i,j,iblk) * ar
               evap    (i,j,iblk) = evap    (i,j,iblk) * ar
               Tref    (i,j,iblk) = Tref    (i,j,iblk) * ar
               Qref    (i,j,iblk) = Qref    (i,j,iblk) * ar
               Uref    (i,j,iblk) = Uref    (i,j,iblk) * ar
               fswthru (i,j,iblk) = fswthru (i,j,iblk) * ar
               fswthru_vdr (i,j,iblk) = fswthru_vdr (i,j,iblk) * ar
               fswthru_vdf (i,j,iblk) = fswthru_vdf (i,j,iblk) * ar
               fswthru_idr (i,j,iblk) = fswthru_idr (i,j,iblk) * ar
               fswthru_idf (i,j,iblk) = fswthru_idf (i,j,iblk) * ar
               alvdr   (i,j,iblk) = alvdr   (i,j,iblk) * ar
               alidr   (i,j,iblk) = alidr   (i,j,iblk) * ar
               alvdf   (i,j,iblk) = alvdf   (i,j,iblk) * ar
               alidf   (i,j,iblk) = alidf   (i,j,iblk) * ar
               fzsal   (i,j,iblk) = fzsal   (i,j,iblk) * ar
               fzsal_g (i,j,iblk) = fzsal_g (i,j,iblk) * ar
               fswthru_uvrdr (i,j,iblk) = fswthru_uvrdr (i,j,iblk) * ar
               fswthru_uvrdf (i,j,iblk) = fswthru_uvrdf (i,j,iblk) * ar
               fswthru_pardr (i,j,iblk) = fswthru_pardr (i,j,iblk) * ar
               fswthru_pardf (i,j,iblk) = fswthru_pardf (i,j,iblk) * ar
            else
               fsens   (i,j,iblk) = c0 
               flat    (i,j,iblk) = c0 
               fswabs  (i,j,iblk) = c0 
               flwout  (i,j,iblk) = -stefan_boltzmann *(Tf(i,j,iblk) + Tffresh)**4 
               fsurf   (i,j,iblk) = c0 
               fcondtop(i,j,iblk) = c0 
               evap    (i,j,iblk) = c0
               Tref    (i,j,iblk) = Tair    (i,j,iblk)
               Qref    (i,j,iblk) = Qa      (i,j,iblk) 
               Uref    (i,j,iblk) = wind    (i,j,iblk) 
               fswthru (i,j,iblk) = c0 
               fswthru_vdr (i,j,iblk) = c0 
               fswthru_vdf (i,j,iblk) = c0 
               fswthru_idr (i,j,iblk) = c0
               fswthru_idf (i,j,iblk) = c0
               alvdr   (i,j,iblk) = c0 
               alidr   (i,j,iblk) = c0 
               alvdf   (i,j,iblk) = c0 
               alidf   (i,j,iblk) = c0 
               fzsal   (i,j,iblk) = c0 
               fzsal_g (i,j,iblk) = c0 
               fswthru_uvrdr (i,j,iblk) = c0 
               fswthru_uvrdf (i,j,iblk) = c0
               fswthru_pardr (i,j,iblk) = c0
               fswthru_pardf (i,j,iblk) = c0
            endif

         enddo
         enddo 


         call ice_timer_stop(timer_couple,iblk)   ! atm/ocn coupling

      end subroutine coupling_atm

      subroutine coupling_ocn (iblk)

      use ice_blocks, only: nx_block, ny_block, get_block, block
      use ice_domain, only: blocks_ice
      use ice_calendar, only: dt, nstreams
      use ice_domain_size, only: ncat
      use ice_flux, only: fpond, fresh, l_mpond_fresh, &
          fhocn_ai, fresh_ai, fsalt_ai, fsalt, &
          fhocn, strairxT, strairyT
      use ice_flux_bgc, only: faero_ocn, fiso_ocn, Qref_iso, fiso_evap, &
          fzsal_ai, fzsal_g_ai, flux_bio, flux_bio_ai, &
          fnit, fsil, famm, fdmsp, fdms, fhum, fdust, falgalN, &
          fdoc, fdic, fdon, ffep, ffed, bgcflux_ice_to_ocn
      use ice_grid, only: tmask, opmask
      use ice_state, only: aicen, aice, aicen_init, aice_init
      use ice_flux, only: flatn_f, fsurfn_f
      use ice_timers, only: timer_couple, ice_timer_start, ice_timer_stop

      integer (kind=int_kind), intent(in) :: &
         iblk            ! block index

      ! local variables

      integer (kind=int_kind) :: &
         ilo,ihi,jlo,jhi, & ! beginning and end of physical domain
         n           , & ! thickness category index
         i,j         , & ! horizontal indices
         k           , & ! tracer index
         nbtrcr          !

      type (block) :: &
         this_block         ! block information for current block

      logical (kind=log_kind) :: &
         skl_bgc     , & !
         calc_Tsfc       !

      real (kind=dbl_kind) :: &
         cszn        , & ! counter for history averaging
         puny        , & !
         ar          , & !           
         rhofresh    , & !
         netsw           ! flag for shortwave radiation presence

      character(len=*), parameter :: subname = '(coupling_ocn)'

      !-----------------------------------------------------------------

         call icepack_query_parameters(puny_out=puny, rhofresh_out=rhofresh)
         call icepack_query_parameters(skl_bgc_out=skl_bgc)
         call icepack_query_tracer_sizes(nbtrcr_out=nbtrcr)
         call icepack_query_parameters(calc_Tsfc_out=calc_Tsfc)
         call icepack_warnings_flush(nu_diag)
         if (icepack_warnings_aborted()) call abort_ice(error_message=subname, &
            file=__FILE__, line=__LINE__)

         call ice_timer_start(timer_couple,iblk)   ! atm/ocn coupling

         do j = 1, ny_block
         do i = 1, nx_block

      !-----------------------------------------------------------------
      ! reduce fresh by fpond for coupling
      !-----------------------------------------------------------------

            if (l_mpond_fresh) then
               fpond(i,j,iblk) = fpond(i,j,iblk) * rhofresh/dt
               fresh(i,j,iblk) = fresh(i,j,iblk) - fpond(i,j,iblk)
            endif

      !----------------------------------------------------------------
      ! Store grid box mean albedos and fluxes before scaling by aice
      !----------------------------------------------------------------

            fresh_ai  (i,j,iblk) = fresh  (i,j,iblk) 
            fsalt_ai  (i,j,iblk) = fsalt  (i,j,iblk)
            fhocn_ai  (i,j,iblk) = fhocn  (i,j,iblk)

            if (nbtrcr > 0) then
            do k = 1, nbtrcr
              flux_bio_ai  (i,j,k,iblk) = flux_bio  (i,j,k,iblk)
            enddo
            endif

         enddo
         enddo

         do j = 1, ny_block
         do i = 1, nx_block
             if ((tmask(i,j,iblk) .or. opmask(i,j,iblk)) .and. aice(i,j,iblk) > c0) then
                ar                 = c1 / aice(i,j,iblk)
                strairxT(i,j,iblk) = strairxT(i,j,iblk) * ar
                strairyT(i,j,iblk) = strairyT(i,j,iblk) * ar
                fresh(i,j,iblk)    =  fresh(i,j,iblk)   * ar
                fhocn(i,j,iblk)    =  fhocn(i,j,iblk)   * ar
                fsalt(i,j,iblk)    =  fsalt(i,j,iblk)   * ar
                flux_bio (i,j,:,iblk) = flux_bio (i,j,:,iblk) * ar
                faero_ocn(i,j,:,iblk) = faero_ocn(i,j,:,iblk) * ar
                Qref_iso (i,j,:,iblk) = Qref_iso (i,j,:,iblk) * ar
                fiso_evap(i,j,:,iblk) = fiso_evap(i,j,:,iblk) * ar
                fiso_ocn (i,j,:,iblk) = fiso_ocn (i,j,:,iblk) * ar
            else
                strairxT(i,j,iblk) =  c0
                strairyT(i,j,iblk) =  c0
                fresh(i,j,iblk)    =  c0
                fhocn(i,j,iblk)    =  c0
                fsalt(i,j,iblk)    =  c0
                flux_bio (i,j,:,iblk) = c0
                faero_ocn(i,j,:,iblk) = c0
                Qref_iso (i,j,:,iblk) = c0
                fiso_evap(i,j,:,iblk) = c0
                fiso_ocn (i,j,:,iblk) = c0
            endif

         enddo
         enddo 
 
      !-----------------------------------------------------------------
      ! Define ice-ocean bgc fluxes
      !-----------------------------------------------------------------

         if (nbtrcr > 0 .or. skl_bgc) then
            call bgcflux_ice_to_ocn (nx_block,       ny_block,           &
                                  flux_bio(:,:,1:nbtrcr,iblk),            &
                                  fnit(:,:,iblk),    fsil(:,:,iblk),      &
                                  famm(:,:,iblk),    fdmsp(:,:,iblk),     &
                                  fdms(:,:,iblk),    fhum(:,:,iblk),      &
                                  fdust(:,:,iblk),   falgalN(:,:,:,iblk), &
                                  fdoc(:,:,:,iblk),  fdic(:,:,:,iblk),    &
                                  fdon(:,:,:,iblk),  ffep(:,:,:,iblk),    &
                                  ffed(:,:,:,iblk))
         endif

         call ice_timer_stop(timer_couple,iblk)   ! atm/ocn coupling

      end subroutine coupling_ocn

!=======================================================================

      subroutine ice_fast_physics

      use ice_boundary, only: ice_HaloUpdate
      use ice_calendar, only: dt, dt_dyn, ndtd, diagfreq, write_restart, istep
      use ice_calendar, only: istep1, calendar, advance_timestep
      use ice_calendar, only: idate, msec
      use ice_diagnostics, only: init_mass_diags, runtime_diags, debug_model, debug_ice
      use ice_diagnostics_bgc, only: hbrine_diags, zsal_diags, bgc_diags
      use ice_domain, only: halo_info, nblocks
      use ice_dyn_eap, only: write_restart_eap
      use ice_dyn_shared, only: kdyn, kridge
      use ice_flux, only: scale_factor, init_history_therm, &
          daidtt, daidtd, dvidtt, dvidtd, dagedtt, dagedtd
      use ice_flux, only: init_flux_atm, init_flux_ocn
      use ice_history, only: accum_hist
      use ice_history_bgc, only: init_history_bgc
      use ice_restart, only: final_restart
      use ice_restart_column, only: write_restart_age, write_restart_FY, &
          write_restart_lvl, write_restart_pond_lvl, &
          write_restart_pond_topo, write_restart_aero, write_restart_fsd, &
          write_restart_iso, write_restart_bgc, write_restart_hbrine, &
          write_restart_snow
      use ice_restart_driver, only: dumpfile
      use ice_restoring, only: restore_ice, ice_HaloRestore
      use ice_step_mod, only: prep_radiation, step_therm1, step_therm2, &
          update_state, step_dyn_horiz, step_dyn_ridge, step_radiation, &
          biogeochemistry, step_prep, step_dyn_wave, step_snow
      use ice_timers, only: ice_timer_start, ice_timer_stop, &
          timer_diags, timer_column,  timer_step, timer_thermo, &
          timer_bound, timer_couple, timer_hist, timer_readwrite

      integer (kind=int_kind) :: &
         iblk        , & ! block index
         k           , & ! dynamics supercycling index
         ktherm          ! thermodynamics is off when ktherm = -1

      real (kind=dbl_kind) :: &
         offset          ! d(age)/dt time offset

      logical (kind=log_kind) :: &
          tr_iage, tr_FY, tr_lvl, tr_fsd, tr_snow, &
          tr_pond_lvl, tr_pond_topo, tr_brine, tr_iso, tr_aero, &
          calc_Tsfc, skl_bgc, solve_zsal, z_tracers, wave_spec

      character(len=*), parameter :: subname = '(ice_fast_physics)'

      character (len=char_len) :: plabeld

      call ice_timer_start(timer_step)   ! start timing entire run

      if (debug_model) then
         plabeld = 'beginning time step'
         do iblk = 1, nblocks
            call debug_ice (iblk, plabeld)
         enddo
      endif

      call icepack_query_parameters(calc_Tsfc_out=calc_Tsfc, skl_bgc_out=skl_bgc, &
           solve_zsal_out=solve_zsal, z_tracers_out=z_tracers, ktherm_out=ktherm, &
           wave_spec_out=wave_spec)
      call icepack_query_tracer_flags(tr_iage_out=tr_iage, tr_FY_out=tr_FY, &
           tr_lvl_out=tr_lvl, tr_pond_lvl_out=tr_pond_lvl, &
           tr_pond_topo_out=tr_pond_topo, tr_brine_out=tr_brine, tr_aero_out=tr_aero, &
           tr_iso_out=tr_iso, tr_fsd_out=tr_fsd, tr_snow_out=tr_snow)
      call icepack_warnings_flush(nu_diag)
      if (icepack_warnings_aborted()) call abort_ice(error_message=subname, &
         file=__FILE__, line=__LINE__)

      call ice_timer_start(timer_couple)  ! atm/ocn coupling

      !call advance_timestep()  ! advance timestep and update calendar data

      !if (z_tracers) call get_atm_bgc                   ! biogeochemistry

      call init_flux_atm  ! Initialize atmosphere fluxes sent to coupler
      call init_flux_ocn  ! initialize ocean fluxes sent to coupler

      call ice_timer_stop(timer_couple)    ! atm/ocn coupling
      !-----------------------------------------------------------------
      ! restoring on grid boundaries
      !-----------------------------------------------------------------

         if (restore_ice) call ice_HaloRestore
      

      !-----------------------------------------------------------------
      ! initialize diagnostics and save initial state values
      !-----------------------------------------------------------------

         call ice_timer_start(timer_diags)  ! diagnostics/history
         call init_mass_diags   ! diagnostics per timestep
         call init_history_therm
         call init_history_bgc
         call ice_timer_stop(timer_diags)   ! diagnostics/history

         call step_prep

         call ice_timer_start(timer_column)  ! column physics
         call ice_timer_start(timer_thermo)  ! thermodynamics

         !$OMP PARALLEL DO PRIVATE(iblk)
         do iblk = 1, nblocks

            if (ktherm >= 0) then

      !-----------------------------------------------------------------
      ! scale radiation fields
      !-----------------------------------------------------------------

               !if (calc_Tsfc) call prep_radiation (iblk)
               !if (debug_model) then
               !   plabeld = 'post prep_radiation'
               !   call debug_ice (iblk, plabeld)
               !endif

               call step_radiation (dt, iblk)
               if (debug_model) then
                  plabeld = 'post step_radiation'
                  call debug_ice (iblk, plabeld)
               endif

      !-----------------------------------------------------------------
      ! get ready for coupling and the next time step
      !-----------------------------------------------------------------

               !call coupling_prep (iblk)
               !if (debug_model) then
               !   plabeld = 'post coupling_prep'
               !  call debug_ice (iblk, plabeld)
               !endif

      !-----------------------------------------------------------------
      ! thermodynamics and biogeochemistry
      !-----------------------------------------------------------------
            
               call step_therm1     (dt, iblk) ! vertical thermodynamics
               if (debug_model) then
                  plabeld = 'post step_therm1'
                  call debug_ice (iblk, plabeld)
               endif

               call coupling_atm (iblk)
               if (debug_model) then
                  plabeld = 'post coupling_atm'
                 call debug_ice (iblk, plabeld)
               endif

            endif ! ktherm > 0

         enddo ! iblk
         !$OMP END PARALLEL DO

         call ice_timer_stop(timer_thermo) ! thermodynamics
         call ice_timer_stop(timer_column) ! column physics

         call ice_timer_stop(timer_step)   ! start timing entire run

      end subroutine ice_fast_physics

!=======================================================================

      subroutine ice_radiation

      use ice_calendar, only: dt
      use ice_domain,   only: nblocks
      use ice_step_mod, only: step_radiation
      use ice_timers,   only: ice_timer_start, ice_timer_stop, &
                               timer_column, timer_thermo
      use ice_arrays_column, only: alvdfn, alidfn, alvdrn, alidrn, &
          fswthrun_vdr, fswthrun_vdf, fswthrun_idr, fswthrun_idf, &
          fswthrun_uvrdr, fswthrun_uvrdf, fswthrun_pardr, fswthrun_pardf, &
          albicen, albsnon, albpndn, apeffn, fzsal_g, fzsal, snowfracn
      use ice_blocks, only: nx_block, ny_block, get_block, block
      use ice_domain, only: blocks_ice
      use ice_calendar, only: dt, nstreams
      use ice_domain_size, only: ncat
      use ice_flux, only: alvdf, alidf, alvdr, alidr, albice, albsno, &
          albpnd, albcnt, apeff_ai, fpond, fresh, l_mpond_fresh, &
          alvdf_ai, alidf_ai, alvdr_ai, alidr_ai, fhocn_ai, &
          fresh_ai, fsalt_ai, fsalt, &
          fswthru_ai, fhocn, fswthru, scale_factor, snowfrac, &
          fswthru_vdr, fswthru_vdf, fswthru_idr, fswthru_idf, &
          fswthru_uvrdr, fswthru_uvrdf, fswthru_pardr, fswthru_pardf, &
          swvdr, swidr, swvdf, swidf, Tf, Tair, Qa, strairxT, strairyT, &
          fsens, flat, fswabs, flwout, evap, Tref, Qref, &
          scale_fluxes, frzmlt_init, frzmlt, Uref, wind
      use ice_flux_bgc, only: faero_ocn, fiso_ocn, Qref_iso, fiso_evap, &
          fzsal_ai, fzsal_g_ai, flux_bio, flux_bio_ai, &
          fnit, fsil, famm, fdmsp, fdms, fhum, fdust, falgalN, &
          fdoc, fdic, fdon, ffep, ffed, bgcflux_ice_to_ocn
      use ice_grid, only: tmask, opmask
      use ice_state, only: aicen, aice, aicen_init, aice_init
      use ice_flux, only: flatn_f, fsurfn_f
      use ice_step_mod, only: ocean_mixed_layer

      integer (kind=int_kind) :: &
         i,j,n,iblk         ! block index

      integer (kind=int_kind) :: &
         ilo, ihi, jlo, jhi
           
      type (block) :: &
         this_block         ! block information for current block

      real (kind=dbl_kind) :: &
         ar, puny

      character(len=*), parameter :: subname = '(ice_radiation)'

         call ice_timer_start(timer_column)  ! column physics
         call ice_timer_start(timer_thermo)  ! thermodynamics

         call icepack_query_parameters(puny_out=puny)


         !$OMP PARALLEL DO PRIVATE(iblk)
         do iblk = 1, nblocks
               !call step_albedo_only(dt, iblk)
               call step_radiation(dt, iblk)
         enddo ! iblk
         !$OMP END PARALLEL DO

         do iblk = 1, nblocks
         do j = 1, ny_block
         do i = 1, nx_block
            alvdf(i,j,iblk) = c0
            alidf(i,j,iblk) = c0
            alvdr(i,j,iblk) = c0
            alidr(i,j,iblk) = c0
         enddo
         enddo
         enddo

         do iblk = 1, nblocks
         this_block = get_block(blocks_ice(iblk),iblk)
         ilo = this_block%ilo
         ihi = this_block%ihi
         jlo = this_block%jlo
         jhi = this_block%jhi

         do n = 1, ncat
         do j = jlo, jhi
         do i = ilo, ihi
            if (aicen_init(i,j,n,iblk) > puny) then

            alvdf(i,j,iblk) = alvdf(i,j,iblk) &
               + alvdfn(i,j,n,iblk)*aicen_init(i,j,n,iblk)
            alidf(i,j,iblk) = alidf(i,j,iblk) &
               + alidfn(i,j,n,iblk)*aicen_init(i,j,n,iblk)
            alvdr(i,j,iblk) = alvdr(i,j,iblk) &
               + alvdrn(i,j,n,iblk)*aicen_init(i,j,n,iblk)
            alidr(i,j,iblk) = alidr(i,j,iblk) &
               + alidrn(i,j,n,iblk)*aicen_init(i,j,n,iblk)

            endif ! aicen_init > puny
         enddo
         enddo
         enddo
         enddo

         do iblk = 1, nblocks
         do j = 1, ny_block
         do i = 1, nx_block
             if ((tmask(i,j,iblk) .or. opmask(i,j,iblk)) .and. aice_init(i,j,iblk) > c0) then
               ar                 = c1 / aice_init(i,j,iblk)
               alvdr   (i,j,iblk) = alvdr   (i,j,iblk) * ar
               alidr   (i,j,iblk) = alidr   (i,j,iblk) * ar
               alvdf   (i,j,iblk) = alvdf   (i,j,iblk) * ar
               alidf   (i,j,iblk) = alidf   (i,j,iblk) * ar
            else
               alvdr   (i,j,iblk) = c0 
               alidr   (i,j,iblk) = c0 
               alvdf   (i,j,iblk) = c0 
               alidf   (i,j,iblk) = c0 
            endif
         enddo ! i
         enddo ! j
         enddo ! iblk

         call ice_timer_stop(timer_thermo) ! thermodynamics
         call ice_timer_stop(timer_column) ! column physics


      end subroutine ice_radiation


      end module CICE_RunMod

!=======================================================================
